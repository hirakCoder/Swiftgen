{"prompt": "Create a SwiftUI todo list app with categories", "completion": "import SwiftUI\n\n@main\nstruct TodoApp: App {\n    var body: some Scene {\n        WindowGroup {\n            ContentView()\n        }\n    }\n}\n\nstruct ContentView: View {\n    @State private var todos: [TodoItem] = []\n    @State private var newTodoTitle = \"\"\n    @State private var selectedCategory = TodoCategory.personal\n    \n    var body: some View {\n        NavigationStack {\n            VStack {\n                // Add new todo\n                HStack {\n                    TextField(\"New todo\", text: $newTodoTitle)\n                        .textFieldStyle(RoundedBorderTextFieldStyle())\n                    \n                    Picker(\"Category\", selection: $selectedCategory) {\n                        ForEach(TodoCategory.allCases, id: \\.self) { category in\n                            Text(category.rawValue).tag(category)\n                        }\n                    }\n                    .pickerStyle(MenuPickerStyle())\n                    \n                    Button(\"Add\") {\n                        addTodo()\n                    }\n                    .disabled(newTodoTitle.isEmpty)\n                }\n                .padding()\n                \n                // Todo list\n                List {\n                    ForEach(TodoCategory.allCases, id: \\.self) { category in\n                        Section(header: Text(category.rawValue)) {\n                            ForEach(todosForCategory(category)) { todo in\n                                TodoRowView(todo: todo, toggleAction: {\n                                    toggleTodo(todo)\n                                })\n                            }\n                            .onDelete { offsets in\n                                deleteTodos(at: offsets, category: category)\n                            }\n                        }\n                    }\n                }\n            }\n            .navigationTitle(\"My Todos\")\n        }\n    }\n    \n    func addTodo() {\n        let newTodo = TodoItem(\n            title: newTodoTitle,\n            category: selectedCategory\n        )\n        todos.append(newTodo)\n        newTodoTitle = \"\"\n    }\n    \n    func toggleTodo(_ todo: TodoItem) {\n        if let index = todos.firstIndex(where: { $0.id == todo.id }) {\n            todos[index].isCompleted.toggle()\n        }\n    }\n    \n    func todosForCategory(_ category: TodoCategory) -> [TodoItem] {\n        todos.filter { $0.category == category }\n    }\n    \n    func deleteTodos(at offsets: IndexSet, category: TodoCategory) {\n        let todosInCategory = todosForCategory(category)\n        for offset in offsets {\n            if let index = todos.firstIndex(where: { $0.id == todosInCategory[offset].id }) {\n                todos.remove(at: index)\n            }\n        }\n    }\n}\n\nstruct TodoItem: Identifiable {\n    let id = UUID()\n    var title: String\n    var isCompleted = false\n    var category: TodoCategory\n}\n\nenum TodoCategory: String, CaseIterable {\n    case personal = \"Personal\"\n    case work = \"Work\"\n    case shopping = \"Shopping\"\n}\n\nstruct TodoRowView: View {\n    let todo: TodoItem\n    let toggleAction: () -> Void\n    \n    var body: some View {\n        HStack {\n            Image(systemName: todo.isCompleted ? \"checkmark.circle.fill\" : \"circle\")\n                .foregroundStyle(todo.isCompleted ? .green : .gray)\n                .onTapGesture(perform: toggleAction)\n            \n            Text(todo.title)\n                .strikethrough(todo.isCompleted)\n                .foregroundStyle(todo.isCompleted ? .gray : .primary)\n            \n            Spacer()\n        }\n        .padding(.vertical, 4)\n    }\n}"}
{"prompt": "Create a SwiftUI calculator app", "completion": "import SwiftUI\n\n@main\nstruct CalculatorApp: App {\n    var body: some Scene {\n        WindowGroup {\n            CalculatorView()\n        }\n    }\n}\n\nstruct CalculatorView: View {\n    @StateObject private var viewModel = CalculatorViewModel()\n    \n    let buttons: [[CalculatorButton]] = [\n        [.clear, .plusMinus, .percent, .divide],\n        [.seven, .eight, .nine, .multiply],\n        [.four, .five, .six, .subtract],\n        [.one, .two, .three, .add],\n        [.zero, .decimal, .equals]\n    ]\n    \n    var body: some View {\n        VStack(spacing: 12) {\n            // Display\n            Text(viewModel.display)\n                .font(.system(size: 72))\n                .fontWeight(.light)\n                .frame(maxWidth: .infinity, alignment: .trailing)\n                .padding()\n                .lineLimit(1)\n                .minimumScaleFactor(0.5)\n            \n            // Buttons\n            ForEach(buttons, id: \\.self) { row in\n                HStack(spacing: 12) {\n                    ForEach(row, id: \\.self) { button in\n                        CalculatorButtonView(button: button) {\n                            viewModel.buttonTapped(button)\n                        }\n                    }\n                }\n            }\n        }\n        .padding()\n        .background(Color.black)\n    }\n}\n\n@MainActor\nclass CalculatorViewModel: ObservableObject {\n    @Published var display = \"0\"\n    \n    private var currentNumber: Double = 0\n    private var previousNumber: Double = 0\n    private var currentOperation: CalculatorOperation?\n    private var shouldResetDisplay = false\n    \n    func buttonTapped(_ button: CalculatorButton) {\n        switch button {\n        case .zero, .one, .two, .three, .four, .five, .six, .seven, .eight, .nine:\n            handleNumber(button.rawValue)\n        case .add, .subtract, .multiply, .divide:\n            handleOperation(button.toOperation())\n        case .equals:\n            calculate()\n        case .clear:\n            clear()\n        case .plusMinus:\n            toggleSign()\n        case .percent:\n            percentage()\n        case .decimal:\n            addDecimal()\n        }\n    }\n    \n    private func handleNumber(_ number: String) {\n        if shouldResetDisplay {\n            display = number\n            shouldResetDisplay = false\n        } else {\n            display = display == \"0\" ? number : display + number\n        }\n        currentNumber = Double(display) ?? 0\n    }\n    \n    private func handleOperation(_ operation: CalculatorOperation) {\n        currentOperation = operation\n        previousNumber = currentNumber\n        shouldResetDisplay = true\n    }\n    \n    private func calculate() {\n        guard let operation = currentOperation else { return }\n        \n        let result: Double\n        switch operation {\n        case .add:\n            result = previousNumber + currentNumber\n        case .subtract:\n            result = previousNumber - currentNumber\n        case .multiply:\n            result = previousNumber * currentNumber\n        case .divide:\n            result = currentNumber != 0 ? previousNumber / currentNumber : 0\n        }\n        \n        display = formatNumber(result)\n        currentNumber = result\n        currentOperation = nil\n        shouldResetDisplay = true\n    }\n    \n    private func clear() {\n        display = \"0\"\n        currentNumber = 0\n        previousNumber = 0\n        currentOperation = nil\n        shouldResetDisplay = false\n    }\n    \n    private func toggleSign() {\n        currentNumber = -currentNumber\n        display = formatNumber(currentNumber)\n    }\n    \n    private func percentage() {\n        currentNumber = currentNumber / 100\n        display = formatNumber(currentNumber)\n    }\n    \n    private func addDecimal() {\n        if !display.contains(\".\") {\n            display += \".\"\n        }\n    }\n    \n    private func formatNumber(_ number: Double) -> String {\n        let formatter = NumberFormatter()\n        formatter.minimumFractionDigits = 0\n        formatter.maximumFractionDigits = 8\n        return formatter.string(from: NSNumber(value: number)) ?? \"0\"\n    }\n}\n\nenum CalculatorButton: String {\n    case zero = \"0\", one = \"1\", two = \"2\", three = \"3\", four = \"4\"\n    case five = \"5\", six = \"6\", seven = \"7\", eight = \"8\", nine = \"9\"\n    case decimal = \".\"\n    case add = \"+\", subtract = \"-\", multiply = \"\u00d7\", divide = \"\u00f7\"\n    case equals = \"=\", clear = \"C\", plusMinus = \"+/-\", percent = \"%\"\n    \n    func toOperation() -> CalculatorOperation? {\n        switch self {\n        case .add: return .add\n        case .subtract: return .subtract\n        case .multiply: return .multiply\n        case .divide: return .divide\n        default: return nil\n        }\n    }\n}\n\nenum CalculatorOperation {\n    case add, subtract, multiply, divide\n}\n\nstruct CalculatorButtonView: View {\n    let button: CalculatorButton\n    let action: () -> Void\n    \n    var buttonColor: Color {\n        switch button {\n        case .clear, .plusMinus, .percent:\n            return Color(.lightGray)\n        case .divide, .multiply, .subtract, .add, .equals:\n            return .orange\n        default:\n            return Color(.darkGray)\n        }\n    }\n    \n    var textColor: Color {\n        switch button {\n        case .clear, .plusMinus, .percent:\n            return .black\n        default:\n            return .white\n        }\n    }\n    \n    var body: some View {\n        Button(action: action) {\n            Text(button.rawValue)\n                .font(.system(size: 32))\n                .frame(width: buttonWidth(), height: buttonHeight())\n                .background(buttonColor)\n                .foregroundStyle(textColor)\n                .clipShape(Circle())\n        }\n    }\n    \n    private func buttonWidth() -> CGFloat {\n        button == .zero ? 148 : 70\n    }\n    \n    private func buttonHeight() -> CGFloat {\n        70\n    }\n}"}
{"prompt": "Add dark mode toggle to a SwiftUI app", "completion": "import SwiftUI\n\nstruct ContentView: View {\n    @AppStorage(\"isDarkMode\") private var isDarkMode = false\n    \n    var body: some View {\n        NavigationStack {\n            VStack {\n                // Your existing content here\n                \n                // Dark mode toggle\n                Toggle(\"Dark Mode\", isOn: $isDarkMode)\n                    .padding()\n            }\n            .navigationTitle(\"Settings\")\n            .preferredColorScheme(isDarkMode ? .dark : .light)\n        }\n    }\n}"}
{"prompt": "Create a SwiftUI weather app with API integration", "completion": "import SwiftUI\n\nstruct WeatherView: View {\n    @StateObject private var weatherService = WeatherService()\n    @State private var city = \"San Francisco\"\n    \n    var body: some View {\n        NavigationStack {\n            VStack(spacing: 20) {\n                // Search bar\n                HStack {\n                    TextField(\"Enter city\", text: $city)\n                        .textFieldStyle(RoundedBorderTextFieldStyle())\n                    \n                    Button(\"Search\") {\n                        Task {\n                            await weatherService.fetchWeather(for: city)\n                        }\n                    }\n                    .buttonStyle(.borderedProminent)\n                }\n                .padding()\n                \n                if weatherService.isLoading {\n                    ProgressView()\n                        .scaleEffect(1.5)\n                } else if let weather = weatherService.currentWeather {\n                    // Weather display\n                    VStack(spacing: 10) {\n                        Text(weather.cityName)\n                            .font(.largeTitle)\n                            .fontWeight(.bold)\n                        \n                        Image(systemName: weather.conditionIcon)\n                            .font(.system(size: 100))\n                            .foregroundStyle(.blue)\n                        \n                        Text(\"\\(Int(weather.temperature))\u00b0\")\n                            .font(.system(size: 72))\n                            .fontWeight(.light)\n                        \n                        Text(weather.description)\n                            .font(.title2)\n                            .foregroundStyle(.secondary)\n                    }\n                    .padding()\n                } else if let error = weatherService.errorMessage {\n                    Text(error)\n                        .foregroundStyle(.red)\n                        .padding()\n                }\n                \n                Spacer()\n            }\n            .navigationTitle(\"Weather\")\n            .task {\n                await weatherService.fetchWeather(for: city)\n            }\n        }\n    }\n}\n\n@MainActor\nclass WeatherService: ObservableObject {\n    @Published var currentWeather: Weather?\n    @Published var isLoading = false\n    @Published var errorMessage: String?\n    \n    private let apiKey = \"YOUR_API_KEY\"\n    private let baseURL = \"https://api.openweathermap.org/data/2.5/weather\"\n    \n    func fetchWeather(for city: String) async {\n        isLoading = true\n        errorMessage = nil\n        \n        guard let url = URL(string: \"\\(baseURL)?q=\\(city)&appid=\\(apiKey)&units=metric\") else {\n            errorMessage = \"Invalid URL\"\n            isLoading = false\n            return\n        }\n        \n        do {\n            let (data, _) = try await URLSession.shared.data(from: url)\n            let response = try JSONDecoder().decode(WeatherResponse.self, from: data)\n            \n            currentWeather = Weather(\n                cityName: response.name,\n                temperature: response.main.temp,\n                description: response.weather.first?.description ?? \"\",\n                conditionIcon: mapConditionToIcon(response.weather.first?.main ?? \"\")\n            )\n        } catch {\n            errorMessage = \"Failed to fetch weather: \\(error.localizedDescription)\"\n        }\n        \n        isLoading = false\n    }\n    \n    private func mapConditionToIcon(_ condition: String) -> String {\n        switch condition {\n        case \"Clear\": return \"sun.max.fill\"\n        case \"Clouds\": return \"cloud.fill\"\n        case \"Rain\": return \"cloud.rain.fill\"\n        case \"Snow\": return \"cloud.snow.fill\"\n        default: return \"questionmark.circle\"\n        }\n    }\n}\n\nstruct Weather {\n    let cityName: String\n    let temperature: Double\n    let description: String\n    let conditionIcon: String\n}\n\nstruct WeatherResponse: Codable {\n    let name: String\n    let main: MainWeather\n    let weather: [WeatherCondition]\n}\n\nstruct MainWeather: Codable {\n    let temp: Double\n}\n\nstruct WeatherCondition: Codable {\n    let main: String\n    let description: String\n}"}
